import json
import threading

import numpy as np
import pandas as pd
import torch

from database import databasemanager
import settings, orchestrator
from utils.database_utils import update_database, log_exception
from utils.util import translate_to_classes
from veracity_detection.score_aggregation import AggregationProcessor


def aggregate(data, agg_type):
    """
    Processes the score aggregation based on a given type

    :param data:
    :param type: only "mean" or "sum" are currently supported
    :return:
    """
    aggregation_processor = AggregationProcessor(agg_type)
    result = aggregation_processor.process(data)
    return result


def predict(claims, identifier):
    """
    Aggregates stance scores per claim with MLP (first step)

    :param claims:
    :param identifier:
    :return:
    """
    try:
        # load trained model
        model = torch.load(settings.trained_model)

        # parse the stance scores only and feed to model
        # loads nested json, groups by claim index, and aggregates the stance scores in a list
        df = pd.json_normalize(claims, 'evidences', ['index']).groupby('index')[['index', 'stance_score']]\
            .agg({'index': 'first', 'stance_score': list})
        claim_indices = df.index
        stance_scores = np.vstack(df.stance_score.to_numpy()).astype(np.float32)

        # get and set prediction
        prediction = model.test_model(torch.from_numpy(stance_scores)).squeeze(1)
        for i, _ in enumerate(claim_indices):
            claims[i]['wise_score'] = prediction[i].item()

        # update database
        claims_json = json.dumps(claims)
        update_database(settings.sentences, settings.results_wiseone_column_status, claims_json, identifier)

        # go next level
        orchestrator.goNextLevel(identifier)
    except Exception as e:
        log_exception(e, identifier)


def predict_rnn(json, identifier):
    """
    Aggregates the claim scores generated by the MLP, uses an RNN (final step)

    :param json:
    :param identifier:
    :return:
    """
    try:
        # load trained model
        model = torch.load(settings.rnn_model)

        # parse the stance scores only and feed to model
        scores = pd.json_normalize(json)['wise_score'].to_numpy(dtype=np.float32)[np.newaxis, :, np.newaxis]

        # get prediction
        prediction = model.test_model(torch.from_numpy(scores)).item()

        # update database
        update_database(settings.results_wise_final_column_name, settings.results_wise_final_column_status,
                        prediction, identifier)

        # translate score to label and save it
        veracity_label = translate_to_classes(prediction, settings.final_low_threshold, settings.final_high_threshold,
                                              settings.final_class_labels)
        databasemanager.update_step(settings.results_table_name, settings.results_veracity_label,
                                    veracity_label, identifier)

        # go next level
        orchestrator.goNextLevel(identifier)
    except Exception as e:
        log_exception(e, identifier)


def predict_mean(json, identifier):
    try:
        # parse the stance scores only and feed to model
        scores = pd.json_normalize(json)['wise_score'].to_numpy(dtype=np.float32)
        prediction = aggregate(scores, 'mean')


        # update database
        update_database(settings.results_wise_final_column_name, settings.results_wise_final_column_status,
                        str(prediction), identifier)

        # translate score to label and save it
        veracity_label = translate_to_classes(prediction, settings.low_threshold, settings.high_threshold,
                                              settings.final_class_labels)
        databasemanager.update_step(settings.results_table_name, settings.results_veracity_label,
                                    veracity_label, identifier)

        # go next level
        thread = threading.Thread(target=orchestrator.goNextLevel, args=(identifier,))
        thread.start()
    except Exception as e:
        log_exception(e, identifier)